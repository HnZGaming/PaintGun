















































                            const string material = "GizmoDrawLine";
                            const float thickness = 0.05f;
                            var color = (Color.Green * 1.3f).ToVector4();
                            var matrix = selectedCharacter.WorldMatrix;
                            var localBox = selectedCharacter.LocalAABB;
                            var halfWidth = localBox.Width / 2;
                            var halfDepth = localBox.Depth / 2;
                            var bottom = matrix.Translation;
                            var top = bottom + matrix.Up * localBox.Height;
                            var worldToLocal = MatrixD.Identity;

                            // top square
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Left * halfWidth + matrix.Forward * halfDepth, matrix.Right, localBox.Width, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Right * halfWidth + matrix.Forward * halfDepth, matrix.Backward, localBox.Width, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Left * halfWidth + matrix.Backward * halfDepth, matrix.Forward, localBox.Width, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Right * halfWidth + matrix.Backward * halfDepth, matrix.Left, localBox.Width, thickness);

                            // vertical lines
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Left * halfWidth + matrix.Forward * halfDepth, matrix.Down, localBox.Height, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Right * halfWidth + matrix.Forward * halfDepth, matrix.Down, localBox.Height, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Left * halfWidth + matrix.Backward * halfDepth, matrix.Down, localBox.Height, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, top + matrix.Right * halfWidth + matrix.Backward * halfDepth, matrix.Down, localBox.Height, thickness);

                            // bottom square
                            MyTransparentGeometry.AddLineBillboard(material, color, bottom + matrix.Left * halfWidth + matrix.Forward * halfDepth, matrix.Right, localBox.Width, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, bottom + matrix.Right * halfWidth + matrix.Forward * halfDepth, matrix.Backward, localBox.Width, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, bottom + matrix.Left * halfWidth + matrix.Backward * halfDepth, matrix.Forward, localBox.Width, thickness);
                            MyTransparentGeometry.AddLineBillboard(material, color, bottom + matrix.Right * halfWidth + matrix.Backward * halfDepth, matrix.Left, localBox.Width, thickness);
























        private bool IsInColorPickerMenu()
        {
            // TODO > whitelist
            //string activeScreen = (MyGuiScreenGamePlay.ActiveGameplayScreen == null ? null : MyGuiScreenGamePlay.ActiveGameplayScreen.ToString());
            //return activeScreen != null && activeScreen.EndsWith("ColorPicker", StringComparison.Ordinal);
            
            return false;
        }
        
        
        
        
        
        
        
        
        
        
        
        
        








        private Vector3I? MirrorPaint(MyCubeGrid grid, int axis, Vector3I originalPosition, Vector3 color)
        {
            switch(axis)
            {
                case 0:
                    if(grid.XSymmetryPlane.HasValue)
                    {
                        var mirrorX = originalPosition + new Vector3I(((grid.XSymmetryPlane.Value.X - originalPosition.X) * 2) - (grid.XSymmetryOdd ? 1 : 0), 0, 0);
                        var slimX = grid.GetCubeBlock(mirrorX);
                        
                        if(slimX != null)
                        {
                            grid.ChangeColor(slimX, color);
                        }
                        
                        return mirrorX;
                    }
                    break;
                    
                case 1:
                    if(grid.YSymmetryPlane.HasValue)
                    {
                        var mirrorY = originalPosition + new Vector3I(0, ((grid.YSymmetryPlane.Value.Y - originalPosition.Y) * 2) - (grid.YSymmetryOdd ? 1 : 0), 0);
                        var slimY = grid.GetCubeBlock(mirrorY);
                        
                        if(slimY != null)
                        {
                            grid.ChangeColor(slimY, color);
                        }
                        
                        return mirrorY;
                    }
                    break;
                    
                case 2:
                    if(grid.ZSymmetryPlane.HasValue)
                    {
                        var mirrorZ = originalPosition + new Vector3I(0, 0, ((grid.ZSymmetryPlane.Value.Z - originalPosition.Z) * 2) + (grid.ZSymmetryOdd ? 1 : 0)); // reversed on odd
                        var slimZ = grid.GetCubeBlock(mirrorZ);
                        
                        if(slimZ != null)
                        {
                            grid.ChangeColor(slimZ, color);
                        }
                        
                        return mirrorZ;
                    }
                    break;
            }
            
            return null;
        }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
























        public List<Vector3> paletteColors = new List<Vector3>();
        public bool paletteMenuShow = false;
        



                        case "palette":
                            PaintGunMod.instance.paletteColors.Clear();
                            if(args[1].Length > 0)
                            {
                                var list = args[1].Split(';');
                                foreach(var c in list)
                                {
                                    hsv = c.Split(',');
                                    if(hsv.Length >= 3 && int.TryParse(hsv[0].Trim(), out h) && int.TryParse(hsv[1].Trim(), out s) && int.TryParse(hsv[2].Trim(), out v))
                                        PaintGunMod.instance.paletteColors.Add(new Vector3(h / 360.0f, s / 100.0f, v / 100.0f));
                                    else
                                        Log.Error("Invalid "+args[0]+" color: " + args[1]);
                                }
                            }
                            continue;
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
            str.Append("Palette=");
            
            if(PaintGunMod.instance.paletteColors.Count > 0)
            {
                foreach(var c in PaintGunMod.instance.paletteColors)
                {
                    paint = c.ToHSVI();
                    str.Append(paint.X).Append(",").Append(paint.Y).Append(",").Append(paint.Z).Append(";");
                }
                
                str.Length -= 1;
            }
            
            str.AppendLine();
            
            
            
            
            
            
            
            
            

                    else if(msg.StartsWith("default", StringComparison.Ordinal))
                    {
                        msg = msg.Substring("default".Length).Trim();
                        
                        int num;
                        
                        if(!int.TryParse(msg, out num))
                        {
                            MyAPIGateway.Utilities.ShowMessage(MOD_NAME, "Argument is not a number.");
                        }
                        else
                        {
                            num = MathHelper.Clamp(num, 1, 14);
                            SetBuildColor(defaultColors[num-1]);
                            MyAPIGateway.Utilities.ShowMessage(MOD_NAME, "Got color from default " + num + " with color " + ColorToString(GetBuildColor()));
                        }
                        
                        return;
                    }



        //PaintGun.cs / public override void UpdateAfterSimulation()


                if(heldByLocalPlayer)
                {
                    if(MyAPIGateway.Input.IsNewMiddleMousePressed()) // TODO << key assignment
                    {
                        mod.paletteMenuShow = !mod.paletteMenuShow;
                        return;
                    }


<?xml version="1.0"?>
<Definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <TransparentMaterials>
    <TransparentMaterial>
    <Id>
        <TypeId>TransparentMaterialDefinition</TypeId>
        <SubtypeId>PaintGunHUDColor</SubtypeId>
      </Id>
      <AlphaMistingEnable>false</AlphaMistingEnable>
      <AlphaSaturation>1</AlphaSaturation>
      <CanBeAffectedByOtherLights>false</CanBeAffectedByOtherLights>
      <Emissivity>0</Emissivity>
      <IgnoreDepth>true</IgnoreDepth>
      <SoftParticleDistanceScale>0</SoftParticleDistanceScale>
      <Texture>Textures\Particles\Square.dds</Texture>
      <UseAtlas>false</UseAtlas>
      <UVOffset>
        <X>0</X>
        <Y>0</Y>
      </UVOffset>
      <UVSize>
        <X>1</X>
        <Y>1</Y>
      </UVSize>
    </TransparentMaterial>
  </TransparentMaterials>
</Definitions>


        public override void Draw() // TODO FINISH!
        {
            try
            {
                if(!init)
                    return;
                
                var myId = MyAPIGateway.Multiplayer.MyId;
                IMyEntity ent;
                
                if(holdingTools.TryGetValue(myId, out ent))
                {
                    if(!MyHud.MinimalHud)
                    {
                        var cam = MyAPIGateway.Session.Camera;
                        var camMatrix = cam.WorldMatrix;
                        var pos = camMatrix.Translation + camMatrix.Forward * 0.1 + camMatrix.Down * 0.2 + camMatrix.Right * 0.05;
                        
                        var bg = HSVtoRGB(GetBuildColor());
                        
                        var viewProjectionMatrix = MatrixD.Invert(cam.ViewMatrix * cam.ProjectionMatrix);
                        var screenPos = new Vector3D(0.32, -0.76, 0);
                        var world = Vector3D.Transform(screenPos, viewProjectionMatrix);
                        
                        var scaleFOV = cam.FovWithZoom / MathHelper.ToRadians(90); // TODO make it better?
                        var width = 0.0066f * scaleFOV;
                        var height = 0.0013f * scaleFOV;
                        
                        // TODO fix shaking when far away from 0,0,0
                        
                        MyTransparentGeometry.AddBillboardOriented("PaintGunHUDColor", bg, world, camMatrix.Left, camMatrix.Up, width, height, 0, true);
                    }
                    
                    if(paletteMenuShow) // TODO resize menu according to FOV ?
                    {
                        var camMatrix = MyAPIGateway.Session.Camera.WorldMatrix;
                        var pos = camMatrix.Translation + camMatrix.Forward * 0.1 + camMatrix.Right * 0.05;
                        var bg = Color.Black * 0.5f;
                        MyQuadD quad;
                        MyUtils.GenerateQuad(out quad, ref pos, 0.01f, 0.03f, ref camMatrix);
                        MyTransparentGeometry.AddQuad("Square", ref quad, bg, ref pos, 0, -1);
                        
                        pos += camMatrix.Up * 0.024;
                        
                        foreach(var v in defaultColors)
                        {
                            //Color c = HSVtoRGB(v);
                            var c = new Vector3(v.X, MathHelper.Clamp(v.Y + 0.8f, 0f, 1f), MathHelper.Clamp(v.Z + 0.55f, 0f, 1f)).HSVtoColor();
                            pos += camMatrix.Down * 0.0041;
                            MyUtils.GenerateQuad(out quad, ref pos, 0.009f, 0.002f, ref camMatrix);
                            MyTransparentGeometry.AddQuad("Square", ref quad, c, ref pos, 0, -1);
                        }
                        
                        return;
                    }
                }
            }
            catch(Exception e)
            {
                Log.Error(e);
            }
        }
        




//////// ACCIDENTAL FIRE EXTINGUISHER ////////

                    if(trigger)
                    {
                        var matrix = Entity.WorldMatrix;
                        matrix.Translation += Entity.WorldMatrix.Forward * 0.17 + Entity.WorldMatrix.Up * 0.06525;
                        
                        var p = new Particle();
                        p.material = particleMaterials[rand.Next(particleMaterials.Count)];
                        p.position = matrix.Translation;
                        p.velocity = player.Physics.LinearVelocity + matrix.Forward * 10f;// + matrix.Left * (-0.5+rand.NextDouble()) + matrix.Up * (-0.5+rand.NextDouble());
                        p.velocity += new Vector3(rand.NextDouble() - 0.5, rand.NextDouble() - 0.5, rand.NextDouble() - 0.5);
                        p.life = 1f;
                        p.color = PaintGunMod.HSVtoRGB(color);
                        p.radius = 0.01f;
                        p.angle = rand.Next(2) == 0 ? -1 : 1;
                        particles.Add(p);
                    }
                    
                    for(int i = particles.Count - 1; i >= 0; i--)
                    {
                        var p = particles[i];
                        p.life -= 1.0f/60.0f;
                        
                        if(p.life <= 0)
                        {
                            particles.RemoveAt(i);
                            continue;
                        }
                        
                        p.position += p.velocity / 60.0f;
                        
                        //if(p.angle > 0)
                        //    p.angle += (float)rand.NextDouble();
                        //else
                        //    p.angle -= (float)rand.NextDouble();
                        
                        //p.radius += (float)(rand.NextDouble() * 0.06);
                        p.radius += 0.05f;
                        //p.velocity *= (rand.Next(80, 100) / 100.0f);
                        p.velocity *= 0.95f;
                        
                        MyTransparentGeometry.AddPointBillboard("Smoke_lit", p.color, p.position, p.radius, p.angle, 0, true, false, false, -1);
                    }
















 /////// ACCIDENTAL WATERFALL //////////

                    if(trigger)
                    {
                        var matrix = Entity.WorldMatrix;
                        matrix.Translation += Entity.WorldMatrix.Forward * 0.17 + Entity.WorldMatrix.Up * 0.06525;
                        
                        var p = new Particle();
                        p.material = particleMaterials[rand.Next(particleMaterials.Count)];
                        p.position = matrix.Translation;
                        p.velocity = player.Physics.LinearVelocity + matrix.Forward * 10f;// + matrix.Left * (-0.5+rand.NextDouble()) + matrix.Up * (-0.5+rand.NextDouble());
                        p.life = 1f;
                        p.color = PaintGunMod.HSVtoRGB(color);
                        p.radius = 0.01f;
                        p.angle = rand.Next(2) == 0 ? -1 : 1;
                        particles.Add(p);
                    }
                    
                    for(int i = particles.Count - 1; i >= 0; i--)
                    {
                        var p = particles[i];
                        p.life -= 1.0f/60.0f;
                        
                        if(p.life <= 0)
                        {
                            particles.RemoveAt(i);
                            continue;
                        }
                        
                        p.position += p.velocity / 60.0f;
                        
                        //if(p.angle > 0)
                        //    p.angle += (float)rand.NextDouble();
                        //else
                        //    p.angle -= (float)rand.NextDouble();
                        
                        //p.radius += (float)(rand.NextDouble() * 0.06);
                        p.radius += 0.05f;
                        //p.velocity *= (rand.Next(80, 100) / 100.0f);
                        p.velocity *= 0.95f;
                        p.velocity += new Vector3(rand.NextDouble(), rand.NextDouble(), rand.NextDouble());
                        
                        MyTransparentGeometry.AddPointBillboard("Smoke_lit", p.color, p.position, p.radius, p.angle, 0, true, false, false, -1);
                    }























            /*
            double V = ((hsv.Z + 1) / 2.0) * 255;
            
            if(V <= 0)
                return Color.Black;
            
            int v = Convert.ToInt32(V);
            double S = hsv.Y + 1; // 0 to 2 because 1 looks the same as 2 in-game... no idea wtf
            
            if(S <= 0)
                return new Color(v, v, v);
            
            double H = (hsv.X * 360);
            double fH = Math.Floor(H / 60);
            double f = H / 60 - fH;
            int hi = Convert.ToInt32(fH) % 6;
            
            int p = Convert.ToInt32(V * (1 - S));
            int q = Convert.ToInt32(V * (1 - f * S));
            int t = Convert.ToInt32(V * (1 - (1 - f) * S));
            
            switch(hi)
            {
                    case 0: return new Color(v, t, p);
                    case 1: return new Color(q, v, p);
                    case 2: return new Color(p, v, t);
                    case 3: return new Color(p, q, v);
                    case 4: return new Color(t, p, v);
                    default: return new Color(v, p, q);
            }
            
            //float H = hsv.X;
            //float S = (hsv.Y + 1) / 2.0f;
            //float V = (hsv.Z + 1) / 2.0f;
            //float V = Math.Abs(H * 6f - 3f) - 1f;
            //float value2 = 2f - Math.Abs(H * 6f - 2f);
            //float value3 = 2f - Math.Abs(H * 6f - 4f);
            //return new Color(MathHelper.Clamp(V * 255 * S * V, 0, 255), MathHelper.Clamp(value2 * 255 * S * V, 0, 255), MathHelper.Clamp(value3 * 255 * S * V, 0, 255));
            
            /*
            double H = hsv.X * 360.0f;
            double S = hsv.Y + 1;
            double V = (hsv.Z + 1f) / 2.0f;
            //while (H < 0) { H += 360; };
            //while (H >= 360) { H -= 360; };
            double R, G, B;
            if (V <= 0)
            {
                R = G = B = 0;
            }
            else if (S <= 0)
            {
                R = G = B = V;
            }
            else
            {
                double hf = H / 60.0;
                int i = (int)Math.Floor(hf);
                double f = hf - i;
                double pv = V * (1 - S);
                double qv = V * (1 - S * f);
                double tv = V * (1 - S * (1 - f));
                switch (i)
                {
                    case 0:
                        R = V;
                        G = tv;
                        B = pv;
                        break;
                    case 1:
                        R = qv;
                        G = V;
                        B = pv;
                        break;
                    case 2:
                        R = pv;
                        G = V;
                        B = tv;
                        break;
                    case 3:
                        R = pv;
                        G = qv;
                        B = V;
                        break;
                    case 4:
                        R = tv;
                        G = pv;
                        B = V;
                        break;
                    case 5:
                        R = V;
                        G = pv;
                        B = qv;
                        break;
                    case 6:
                        R = V;
                        G = tv;
                        B = pv;
                        break;
                    case -1:
                        R = V;
                        G = pv;
                        B = qv;
                        break;
                    default:
                        R = G = B = V;
                        break;
                }
            }
            
            return new Color(MathHelper.Clamp((int)(R * 255.0), 0, 255), MathHelper.Clamp((int)(G * 255.0), 0, 255), MathHelper.Clamp((int)(B * 255.0), 0, 255));
             */
















			/*
			var view = MyAPIGateway.Session.ControlledObject.GetHeadMatrix(true, true);
			var maxRange = (MyAPIGateway.Session.CreativeMode ? 2 : 2);
			var start = player.WorldAABB.Center + (view.Up * 0.6);
			var target = player.WorldAABB.Center + (view.Forward * maxRange) + (view.Up * 0.6);
			
			List<Vector3I> hits = new List<Vector3I>();
			grid.RayCastCells(start, target, hits, null, false);
			IMySlimBlock block;
			
			foreach(var hit in hits)
			{
				block = grid.GetCubeBlock(hit);
				
				if(block != null)
					return block;
			}
			
			return null;
			
			/*
            Vector3D targetPos = Vector3D.Transform(target, grid.WorldMatrixNormalizedInv) / grid.GridSize;
            Vector3I pos;
            grid.FixTargetCube(out pos, targetPos);
            return grid.GetCubeBlock(pos);
            
            /*
            List<Vector3I> hits = new List<Vector3I>();
            grid.RayCastCells(start, target, hits, null, true);
            IMySlimBlock block;
            
            foreach(var hit in hits)
            {
                block = grid.GetCubeBlock(hit);
                
                if(block != null)
                    return block;
            }
            
            return null;
            
            /*
            var pos = grid.RayCastBlocks(player.WorldAABB.Center, target);
            MyAPIGateway.Utilities.ShowNotification("aimat="+(pos.HasValue ? pos.Value.ToString() : "null"), 160, MyFontEnum.Green);
            
            List<Vector3I> hit = new List<Vector3I>();
            grid.RayCastCells(player.WorldAABB.Center, target, hit, null, true);
            MyAPIGateway.Utilities.ShowNotification("hit count="+hit.Count+String.Join("\n", hit), 160, MyFontEnum.Green);
            
            return pos.HasValue ? grid.GetCubeBlock(pos.Value) : null;
            
            /*
            var pos = grid.RayCastBlocks(player.WorldAABB.Center, target);
            return pos.HasValue ? grid.GetCubeBlock(pos.Value) : null;
			 */
        
        
        
        
        
        
        
        
        
        
        
        /*
        public class PaintStatus
        {
            public float progress = 0;
            public long started = 0;
            
            public PaintStatus()
            {
                started = DateTime.UtcNow.Ticks;
            }
        }
        
        Dictionary<string, PaintStatus> paintProgress = new Dictionary<string, PaintStatus>();
        
        public string BlockToKey(IMySlimBlock block)
        {
            return block.CubeGrid.EntityId+":"+block.Position.ToString();
        }
        
        /*
        // TODO REMOVE THIS CLUTTER ! xD
        public bool __HoldingTool(bool trigger)
        {
            try
            {
                /*
                var colorList = MyAPIGateway.Session.GetCheckpoint("null").CharacterToolbar.ColorMaskHSVList;
                var color = colorList[0];
         */
        
        /*
                var test = Sandbox.Game.Entities.MyCubeBuilder.AllPlayersColors;
                //var id =  new MyObjectBuilder_Checkpoint.PlayerId(MyAPIGateway.Session.Player.SteamUserId);
                
                var id = new Sandbox.Game.World.MyPlayer.PlayerId(MyAPIGateway.Session.Player.SteamUserId);
                
                MyAPIGateway.Utilities.ShowNotification("test="+test[id][0], 16, MyFontEnum.Green);
         */
        
        //MyAPIGateway.Utilities.ShowNotification("color="+color, 16, MyFontEnum.Green);
        
        /*
                var colors = MyAPIGateway.Session.GetCheckpoint("null").AllPlayersColors.Dictionary;
                if(colors != null)
                {
                    Log.Info("colors ok");
                    
                    var id =  new MyObjectBuilder_Checkpoint.PlayerId(MyAPIGateway.Session.Player.SteamUserId);
                    var colorList = colors[id];
                    
                    if(colorList != null)
                    {
                        //Log.Info("color list ok");
                        
                        color = colorList[0];
                        
                        MyAPIGateway.Utilities.ShowNotification("color="+color, 16, MyFontEnum.Blue);
                    }
                }
         */
        
        /*
                if(toolStatus == null)
                {
                    toolStatus = MyAPIGateway.Utilities.CreateNotification("", 300, MyFontEnum.White);
                    toolStatus.Hide();
                }
                
                var player = MyAPIGateway.Session.Player.Controller.ControlledEntity.Entity;
                var grid = MyAPIGateway.CubeBuilder.FindClosestGrid();
                
                if(grid == null)
                {
                    if(trigger)
                    {
                        SetToolStatus("No ship target for painting.\nPress your LIGHTS key to stop painting.", MyFontEnum.Red);
                    }
                    else if(pickColor)
                    {
                        SetToolStatus("Aim at a block to pick its color...\nor type /pg cancel to cancel the process.", MyFontEnum.Red);
                    }
                }
                else
                {
                    var view = MyAPIGateway.Session.ControlledObject.GetHeadMatrix(true, true);
                    var target = player.WorldAABB.Center + (view.Forward * grid.GridSize) + (view.Up * 0.6);
                    var pos = grid.WorldToGridInteger(target);
                    var block = grid.GetCubeBlock(pos);
                    string blockName = null;
                    
                    if(block != null)
                    {
                        if(block.FatBlock == null)
                        {
                            blockName = block.ToString();
                        }
                        else
                        {
                            blockName = block.FatBlock.DefinitionDisplayNameText;
                        }
                        
                        if(pickColor)
                        {
                            pickColor = false;
                            SetColor(block.GetColorMask());
                            MyAPIGateway.Utilities.ShowMessage(MOD_NAME, "Picked " + blockName + "'s color with " + String.Format("Hue: {0}; Saturation: {1}; Value: {2}", color.X, color.Y, color.Z));
                            return false;
                        }
                        
                        if(block.HasDeformation || block.CurrentDamage > 0 || (block.FatBlock != null && !block.FatBlock.IsFunctional))
                        {
                            SetToolStatus("Paint target: " + blockName + "\n" + (block.HasDeformation || block.CurrentDamage > 0 ? "Block is damaged or deformed and can't be painted!" : "Block is not fully built and can't be painted!"), MyFontEnum.Red);
                            return false;
                        }
                        
                        if(!trigger)
                        {
                            SetToolStatus("Paint target: " + blockName + "\nPress your LIGHTS key to start painting.", MyFontEnum.DarkBlue);
                        }
                    }
                    else
                    {
                        if(pickColor)
                        {
                            SetToolStatus("Aim at a block to pick its color...\nor type /pg cancel to cancel the process.", MyFontEnum.Red);
                        }
                        else if(trigger)
                        {
                            SetToolStatus("No block target for painting.\nPress your LIGHTS key to stop painting.", MyFontEnum.Red);
                        }
                    }
                    
                    if(trigger && block != null)
                    {
                        var blockColor = block.GetColorMask();
                        //RoundVector(ref blockColor, 2);
                        //RoundVector(ref color, 2);
                        
                        Vector3 blockSize;
                        block.ComputeScaledHalfExtents(out blockSize);
                        blockSize = ((blockSize * 2) / block.CubeGrid.GridSize);
                        
                        if(blockColor == color)
                        {
                            SetToolStatus(blockName + " is painted.\nPress your LIGHTS key to stop painting.", MyFontEnum.Green);
                            return false;
                        }
                        
                        /*
                        byte paintSpeed = 10; // (byte)((1 / Math.Max(blockSize.Volume * 0.33, 1)) * 10);
                        
                        var blockRGB = blockColor.HSVtoColor();
                        var colorRGB = color.HSVtoColor();
                        
                        if(blockRGB == colorRGB)
                        {
                            toolStatus.Show();
                            toolStatus.Text = blockName + " is painted.\nPress your LIGHTS key to stop painting.";
                            toolStatus.Font = MyFontEnum.Green;
                            return;
                        }
                        
                        var grayRGB = GRAY.HSVtoColor();
                        string key = BlockToKey(block);
                        PaintStatus paintStatus;
                        
                        if(paintProgress.TryGetValue(key, out paintStatus))
                        {
                            // continue painting
                            toolStatus.Text = "???% painting " + blockName + "...\nPress your LIGHTS key to stop painting.";
                            
                            paintStatus.started += (TimeSpan.TicksPerSecond * 2);
                            
                            if(blockRGB.R > colorRGB.R)
                                blockRGB.R = (byte)Math.Max(blockRGB.R - paintSpeed, colorRGB.R);
                            else
                                blockRGB.R = (byte)Math.Min(blockRGB.R + paintSpeed, colorRGB.R);
                            
                            if(blockRGB.G > colorRGB.G)
                                blockRGB.G = (byte)Math.Max(blockRGB.G - paintSpeed, colorRGB.G);
                            else
                                blockRGB.G = (byte)Math.Min(blockRGB.G + paintSpeed, colorRGB.G);
                            
                            if(blockRGB.B > colorRGB.B)
                                blockRGB.B = (byte)Math.Max(blockRGB.B - paintSpeed, colorRGB.B);
                            else
                                blockRGB.B = (byte)Math.Min(blockRGB.B + paintSpeed, colorRGB.B);
                            
                            if(blockRGB.A > colorRGB.A)
                                blockRGB.A = (byte)Math.Max(blockRGB.B - paintSpeed, colorRGB.A);
                            else
                                blockRGB.A = (byte)Math.Min(blockRGB.B + paintSpeed, colorRGB.A);
                            
                            if(blockRGB == colorRGB)
                            {
                                MyAPIGateway.Utilities.ShowMessage("DEBUG", "finished painting = " + blockRGB.ToString()); // TODO REMOVE
                                paintProgress.Remove(key);
                            }
                        }
                        else
                        {
                            // remove paint
                            toolStatus.Text = "???% removing paint from " + blockName + "...\nPress your LIGHTS key to stop painting.";
                            
                            if(blockRGB == grayRGB)
                            {
                                MyAPIGateway.Utilities.ShowMessage("DEBUG", "finished removing paint = " + blockRGB.ToString()); // TODO REMOVE
                                paintProgress.Add(key, new PaintStatus());
                                return;
                            }
                            
                            if(blockRGB.R > grayRGB.R)
                                blockRGB.R = (byte)Math.Max(blockRGB.R - paintSpeed, grayRGB.R);
                            else
                                blockRGB.R = (byte)Math.Min(blockRGB.R + paintSpeed, grayRGB.R);
                            
                            if(blockRGB.G > grayRGB.G)
                                blockRGB.G = (byte)Math.Max(blockRGB.G - paintSpeed, grayRGB.G);
                            else
                                blockRGB.G = (byte)Math.Min(blockRGB.G + paintSpeed, grayRGB.G);
                            
                            if(blockRGB.B > grayRGB.B)
                                blockRGB.B = (byte)Math.Max(blockRGB.B - paintSpeed, grayRGB.B);
                            else
                                blockRGB.B = (byte)Math.Min(blockRGB.B + paintSpeed, grayRGB.B);
                            
                            if(blockRGB.A > grayRGB.A)
                                blockRGB.A = (byte)Math.Max(blockRGB.B - paintSpeed, grayRGB.A);
                            else
                                blockRGB.A = (byte)Math.Min(blockRGB.B + paintSpeed, grayRGB.A);
                        }
                        
                        blockColor = blockRGB.ColorToHSV();
         */
        /*
                        float paintSpeed = (float)(1 / Math.Max(blockSize.Volume * 0.33, 1));
                        
                        if(blockColor.X == color.X)
                        {
                            paintSpeed *= PAINT_SPEED;
                            paintSpeed *= MyAPIGateway.Session.WelderSpeedMultiplier;
                            
                            float diff = (Math.Abs(blockColor.Y - color.Y) + Math.Abs(blockColor.Z - color.Z)) / 4;
                            float percent = 100 - (float)Math.Round(diff * 100, 0);
                            
                            SetToolStatus(percent + "% painting " + blockName + "...\nPress your LIGHTS key to stop painting.", MyFontEnum.Blue);
                            
                            if(blockColor.Y > color.Y)
                                blockColor.Y = Math.Max(blockColor.Y - paintSpeed, color.Y);
                            else
                                blockColor.Y = Math.Min(blockColor.Y + paintSpeed, color.Y);
                            
                            if(blockColor.Z > color.Z)
                                blockColor.Z = Math.Max(blockColor.Z - paintSpeed, color.Z);
                            else
                                blockColor.Z = Math.Min(blockColor.Z + paintSpeed, color.Z);
                        }
                        else
                        {
                            paintSpeed *= DEPAINT_SPEED;
                            paintSpeed *= MyAPIGateway.Session.GrinderSpeedMultiplier;
                            
                            float diff = (Math.Abs(blockColor.Y - DEFAULT_COLOR.Y) + Math.Abs(blockColor.Z - DEFAULT_COLOR.Z)) / 4;
                            float percent = 100 - (float)Math.Round(diff * 100, 0);
                            SetToolStatus(percent + "% removing paint from " + blockName + "...\nPress your LIGHTS key to stop painting.", MyFontEnum.Blue);
                            
                            blockColor.Y = Math.Max(blockColor.Y - paintSpeed, DEFAULT_COLOR.Y);
                            
                            if(blockColor.Z > 0)
                                blockColor.Z = Math.Max(blockColor.Z - paintSpeed, DEFAULT_COLOR.Z);
                            else
                                blockColor.Z = Math.Min(blockColor.Z + paintSpeed, DEFAULT_COLOR.Z);
                            
                            if(blockColor.Y == DEFAULT_COLOR.Y && blockColor.Z == DEFAULT_COLOR.Z)
                            {
                                blockColor.X = color.X;
                            }
                        }
                        
                        /*
                        ushort percent;
                        float paintSpeed = (float)(1 / Math.Round(blockSize.Volume * 0.8, 0));
                        
                        //MyAPIGateway.Utilities.ShowNotification("blockColor="+blockColor+"; color="+color, 160, MyFontEnum.White); // TODO REMOVE
                        
                        // TODO close enough HUE without depainting ?
                        
                        if(blockColor.X == color.X) // && blockColor.Z == color.Z) // hue is the same, proceed to painting by adding to saturation and value
                        {
                            paintSpeed *= PAINT_SPEED;
                            percent = (ushort)Math.Round(((1 + blockColor.Y) / (1 + color.Y)) * 100, 0);
                            toolStatus.Text = percent + "% painting " + blockName + "...\nPress your LIGHTS key to stop painting.";
                            
                            blockColor.Y = Math.Min(blockColor.Y + paintSpeed, color.Y);
                            
                            if(blockColor.Z > color.Z)
                                blockColor.Z = Math.Max(blockColor.Z - paintSpeed, color.Z);
                            else
                                blockColor.Z = Math.Min(blockColor.Z + paintSpeed, color.Z);
                            
                            MyAPIGateway.Utilities.ShowMessage("DEBUG", "colorizing... y="+blockColor.Y+"; z="+blockColor.Z); // TODO REMOVE
                        }
                        else // hue is not the same, decolorize by removing from saturation and value
                        {
                            paintSpeed *= DEPAINT_SPEED;
                            percent = (ushort)Math.Round((1 - ((1 + blockColor.Y) / 2)) * 100, 0);
                            toolStatus.Text = percent + "% removing paint on " + blockName + "...\nPress your LIGHTS key to stop.";
                            
                            MyAPIGateway.Utilities.ShowMessage("DEBUG", "decolorizing... y="+blockColor.Y+"; z="+blockColor.Z); // TODO REMOVE
                            
                            blockColor.Y = Math.Max(blockColor.Y - paintSpeed, -1);
                            
                            if(blockColor.Z > 0)
                                blockColor.Z = Math.Max(blockColor.Z - paintSpeed, 0);
                            else
                                blockColor.Z = Math.Min(blockColor.Z + paintSpeed, 0);
                            
                            if(blockColor.Y == -1 && blockColor.Z == 0)
                            {
                                MyAPIGateway.Utilities.ShowMessage("DEBUG", "reached full decoloration; y="+blockColor.Y+"; z="+blockColor.Z); // TODO REMOVE
                                
                                blockColor.X = color.X;
                            }
                        }
         */
        
        /*
                        if(blockColor.X == color.X && blockColor.Z == color.Z)
                        {
                            percent = (ushort)Math.Round(((1 + blockColor.Y) / (1 + color.Y)) * 100, 0);
                            toolStatus.Text = percent + "% painting " + blockName + "...\nPress your LIGHTS key to stop painting.";
                            
                            blockColor.Y = Math.Min(blockColor.Y + PAINT_SPEED, color.Y);
                            
                            MyAPIGateway.Utilities.ShowMessage("DEBUG", "colorizing..."); // TODO REMOVE
                        }
                        else
                        {
                            percent = (ushort)Math.Round((1 - ((1 + blockColor.Y) / 2)) * 100, 0);
                            toolStatus.Text = percent + "% removing paint on " + blockName + "...\nPress your LIGHTS key to stop.";
                            
                            MyAPIGateway.Utilities.ShowMessage("DEBUG", "decolorizing..."); // TODO REMOVE
                            
                            blockColor.Y = Math.Max(blockColor.Y - DEPAINT_SPEED, -1);
                            
                            if(blockColor.Y == -1)
                            {
                                blockColor.X = color.X;
                                blockColor.Z = color.Z;
                                
                                MyAPIGateway.Utilities.ShowMessage("DEBUG", "reached full decoloration"); // TODO REMOVE
                            }
                        }
         */
        /*
                        grid.ColorBlocks(pos, pos, blockColor);
                        return true;
                        
                        /*
                        bool coloring = true;
                        
                        if(blockColor != GRAY)
                        {
                            coloring = false;
                            blockColor.X = GRAY.X;
                            blockColor.Z = GRAY.Z;
                        }
                        else if(blockColor.X == GRAY.X && blockColor.Z == GRAY.Z && blockColor.Y > -1)
                        {
                            coloring = false;
                            blockColor.Y = Math.Max(blockColor.Y - DEPAINT_SPEED, -1);
                        }
                        else
                        {
                            if(blockColor.X != color.X || blockColor.Z != color.Z)
                            {
                                blockColor = color;
                                blockColor.Y = -1;
                            }
                            else
                            {
                                blockColor.Y = Math.Min(blockColor.Y + PAINT_SPEED, color.Y);
                            }
                        }
                        
                        grid.ColorBlocks(pos, pos, blockColor);
                        
                        ushort percent = (ushort)Math.Round(((1 + blockColor.Y) / (1 + color.Y)) * 100, 0);
                        
                        toolStatus.Show();
                        if(coloring)
                            toolStatus.Text = percent + "% painting " + blockName + "...\nPress your LIGHTS key to stop painting.";
                        else
                            toolStatus.Text = percent + "% removing paint on " + blockName + "...\nPress your LIGHTS key to stop.";
                        toolStatus.Font = MyFontEnum.Blue;
         */
        /*
                    }
                }
                
                /*
                var view = MyAPIGateway.Session.ControlledObject.GetHeadMatrix(true, true);
                var target = player.WorldAABB.Center + (view.Forward * 2) + (view.Up * 0.75);
                
                var box = new BoundingBoxD(target - 0.1, target + 0.1);
                var ents = MyAPIGateway.Entities.GetEntitiesInAABB(ref box);
                //List<Vector3I> hit = new List<Vector3I>();
                
                foreach(var ent in ents)
                {
                    if(ent is IMyCubeGrid && ent.Physics != null && !ent.Physics.IsPhantom)
                    {
                        var grid = ent as IMyCubeGrid;
                        
                        var pos = grid.WorldToGridInteger(target);
                        var block = grid.GetCubeBlock(pos);
                        MyAPIGateway.Utilities.ShowNotification("pos="+pos+"; block="+(block == null ? "null" : block.ToString()), 16, MyFontEnum.Red);
                        
                        if(trigger && block != null)
                        {
                            MyAPIGateway.Utilities.ShowNotification("Color at " + pos, 1000, MyFontEnum.Green);
                            grid.ColorBlocks(pos, pos, color);
                        }
                        
                        break;
                        
                        /*
                        hit.Clear();
                        grid.RayCastCells(view.Translation, target + (view.Forward * 2), hit, null, true);
                        
                        if(hit.Count > 0)
                        {
                            MyAPIGateway.Utilities.ShowNotification("Hit count="+hit.Count+"; list="+String.Join(",", hit), 16, MyFontEnum.Red);
                            block = grid.GetCubeBlock(hit[0]);
                            
                            if(trigger)
                            {
                                MyAPIGateway.Utilities.ShowNotification("Color at " + hit[0], 1000, MyFontEnum.Green);
                                grid.ColorBlocks(hit[0], hit[0], new Vector3(0,0,0));
                                
                                if(block == null)
                                {
                                    //MyAPIGateway.Utilities.ShowNotification("No block found!", 1000, MyFontEnum.Red);
                                }
                                else
                                {
                                    MyAPIGateway.Utilities.ShowNotification(block.ToString() + " colored!", 1000, MyFontEnum.Green);
                                }
                            }
                            
                            break;
                        }
                    }
                }
         */
        
        
        
        
        /*
            if(!MyAPIGateway.Entities.IsRaycastBlocked(view.Translation, target))
                return;
            
            /*
            MyAPIGateway.Entities.GetEntities(null,
                delegate( IMyEntity entity )
                {
                    var ObjectPos = GetPosition(entity);
                    LineD LineToTarget = new LineD(position, ObjectPos);
                    RayD Intersector = new RayD(LineToTarget.To, -LineToTarget.Direction); //ray from target to radar ship
                    if (LineToTarget.Length < range)
                    {
                        bool IsBlocked = false;
                        double TargetRange = 0.0;
                        double? RangeFromTarget = null;
                        if ((entity is IMyCubeGrid) || (entity is IMyVoxelMap)) TargetRange = entity.WorldVolume.Radius * WorldVolumeMultiplier;
                        else { }
                        if ((ObjectPos - ShipPos).Length() > (ShipRange + TargetRange))
                        {
                            RangeFromTarget = Intersector.Intersects(GetShipSphere()); //get point on overall sphere of radar ship (=outside all blocks)
                            if (RangeFromTarget.HasValue)
                            {
                                LineToTarget.From = Intersector.Position + Intersector.Direction * RangeFromTarget.Value;
                            }
                            LineToTarget.To -= LineToTarget.Direction * TargetRange;
                            IsBlocked = MyAPIGateway.Entities.IsRaycastBlocked(LineToTarget.From, LineToTarget.To);
                        }
                        else
                        {
                        }
                        if (IsBlocked) { } else foreach (var selector in selectors) selector.Examine(entity);
                    }
                    return false;
                }
               );
         */
        
        /*
            var ray = new RayD(view.Translation, view.Forward);
            IMySlimBlock block = null;
            List<Vector3I> hit = new List<Vector3I>();
            
            ents.Clear();
            MyAPIGateway.Entities.GetEntities(ents,
                                              delegate(IMyEntity ent)
                                              {
                                                  if(block != null)
                                                      return false;
                                                  
                                                  if(ent is IMyCubeGrid)
                                                  {
                                                      var cast = ray.Intersects(ent.WorldVolume);
                                                      
                                                      if(cast.HasValue)
                                                      {
                                                          var grid = ent as IMyCubeGrid;
                                                          var hitBlock = grid.RayCastBlocks(view.Translation, target);
                                                          
                                                          if(hitBlock.HasValue)
                                                          {
                                                              block = grid.GetCubeBlock(hitBlock.Value);
                                                              return true;
                                                          }
                                                          
                                                          hit.Clear();
                                                          grid.RayCastCells(view.Translation, target, hit, null, false);
                                                          
                                                          if(hit.Count > 0)
                                                          {
                                                              MyAPIGateway.Utilities.ShowNotification("Hit count="+hit.Count+"; list="+String.Join(",", hit), 16, MyFontEnum.Green);
                                                              block = grid.GetCubeBlock(hit[0]);
                                                              return true;
                                                          }
                                                      }
                                                  }
                                                  
                                                  return false;
                                              });
            
            
            MyAPIGateway.Utilities.ShowNotification("block="+block, 16, MyFontEnum.Red);
            
            if(trigger)
            {
                if(block != null)
                {
                    block.CubeGrid.ColorBlocks(block.Position, block.Position, color);
                    MyAPIGateway.Utilities.ShowNotification("Painted!", 1000, MyFontEnum.Green);
                }
            }
         */
        /*
            }
            catch(Exception e)
            {
                Log.Error(e);
            }
            
            return false;
        }
         */